import { NodeTypes } from "../../types/NodeTypes";
import { Document } from "../Document";
import { Element } from "../Element";
import { NodeStore } from "./NodeStore";
import { ChildNodeList } from "./ChildNodeList";
export declare abstract class Node<NV = null> {
    wasmId: number;
    nodeStore: NodeStore<NV>;
    readonly _childNodes: ChildNodeList<NV>;
    readonly ELEMENT_NODE = NodeTypes.ELEMENT_NODE;
    readonly ATTRIBUTE_NODE = NodeTypes.ATTRIBUTE_NODE;
    readonly TEXT_NODE = NodeTypes.TEXT_NODE;
    readonly PROCESSING_INSTRUCTION_NODE = NodeTypes.PROCESSING_INSTRUCTION_NODE;
    readonly COMMENT_NODE = NodeTypes.COMMENT_NODE;
    readonly DOCUMENT_NODE = NodeTypes.DOCUMENT_NODE;
    readonly DOCUMENT_TYPE_NODE = NodeTypes.DOCUMENT_TYPE_NODE;
    readonly DOCUMENT_FRAGMENT_NODE = NodeTypes.DOCUMENT_FRAGMENT_NODE;
    constructor(nodeType: NodeTypes);
    dump(): string;
    get childNodes(): ChildNodeList<NV>;
    get nodeType(): NodeTypes;
    get ownerDocument(): Document;
    get parent(): Node | null;
    get parentNode(): Node | null;
    get parentElement(): Element | null;
    get firstChild(): Node | null;
    get lastChild(): Node | null;
    get nextSibling(): Node | null;
    get previousSibling(): Node | null;
    hasChildNodes(): boolean;
    get isConnected(): boolean;
    get nodeValue(): NV;
    set nodeValue(nodeValue: NV);
    removeChild(node: Node): Node;
    insertBefore(newNode: Node, referenceNode: Node | null): Node;
    appendChild(node: Node): Node<null>;
    replaceChild(newChild: Node, oldChild: Node): Node;
    cloneNode(deep?: boolean): Node;
    protected _cloneNodeShallow(): Node;
    normalize(): void;
    contains(other: Node | null): boolean;
    remove(): void;
    getRootNode(): Node | Document;
}
